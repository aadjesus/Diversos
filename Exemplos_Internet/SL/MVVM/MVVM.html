<html>
<head><title>Composite Application Reloaded</title>
	<style type="text/css">

	body
	{
		font-size: 11pt;
		font-family:Calibri, Sans-Serif;
	}

	h1, h2, h3
	{
		margin-top:24.0pt;
		margin-right:0cm;
		margin-bottom:0cm;
		margin-left:0cm;
		margin-bottom:.0001pt;
		line-height:115%;
		page-break-after:avoid;
		font-size:14.0pt;
		font-family:"Cambria","serif";
		color:#365F91;
	}
	
	code
	{
		border-style: none;
		border-color: inherit;
		border-width: medium;
		font-family:Consolas;
		color:#1F497D;
	}
	
	pre
	{
		line-height: 115%;
		font-size: 10.0pt;
		font-family: Consolas;
		border-style: solid;
		border-color: Maroon;
		border-width: 1px;
		margin-left: 0cm;
		margin-right: 0cm;
		margin-top: 0cm;
		margin-bottom: 10.0pt;
		padding: 3px;
		background: #FDE9D9;
	}
	
	</style>
</head>
<body>
<a href="CompositeApplicationEx/MVVM.zip">Download MVVM.zip - 435.96 KB</a><br />
<a href="CompositeApplicationEx/Composite_application_reloaded.pdf">Download Composite Application Reloaded.pdf - 675.26 KB</a><br />
<p />

<h2>Introduction</h2>
As I was starting a new project I was looking for a library that will help me write 
a composite application, i.e. an application with a main shell (window) and pluggable extensions 
(DLLs / modules) to be added to it dynamically; 
A library like <a href="http://compositewpf.codeplex.com/">Prism</a> but hopefully much simpler.
<p/>
Many pieces of the puzzle could already be found elsewhere. 
The application had to have a clear separation between data and view, 
i.e. an <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">MVVM</a> approach. 
Services had to be linked automatically with something like <a href="http://mef.codeplex.com/">MEF</a>. 
Data validation should be automatic (thanks to <code>ValidationAttribute</code>(s)).
<p/>
But improvement had to be made regarding disconnected messaging and view resolution. 
About the view resolution, i.e. the process of finding the appropriate view to represent a 
given business data object, I wanted to just tag the view with an attribute, such as 
<code>DataView(typeof(BusinessData1))</code> and let the library take care of the rest. 
This is where this library came from.
<p />
<h4>What's new?</h4>
Performance improvements (in <code>Composition.GetView()</code>), 
<a href="#commands">Commands</a> simplification, <a href="#pocobinding">POCO Bindings</a>, 
WP7 support and <a href="http://mef.codeplex.com/">MEF</a> for WP7.
<br />
<a href="http://compositeapp.codeplex.com/">Codeplex project</a>.
<p/>
<p/>
<h4>Table of content</h4>
<a href="#samples">Samples</a><br />
<a href="#aboutmef">About MEF and MVVM</a><br />
<a href="#whatiscapp">What does a composite application look like</a><br />
<a href="#mainf">Core Features</a><br />
&nbsp; &nbsp; <a href="#getview">Composition GetView</a><br />
&nbsp; &nbsp; <a href="#viewmodel">Validation and ViewModelBase</a><br />
&nbsp; &nbsp; <a href="#msg">Disconnected Messaging</a><br />
&nbsp; &nbsp; <a href="#commands">Commands</a><br />
<a href="#otherf">Utilities</a><br />
&nbsp; &nbsp; <a href="#invoker">UIThread Invoke</a><br />
&nbsp; &nbsp; <a href="#designtimemodel">Design time model initialization</a><br />
&nbsp; &nbsp; <a href="#pocobinding">POCO Bindings</a><br />
&nbsp; &nbsp; <a href="#foreach">Foreach</a><br />
<a href="#summary">Summary</a><br />
<a href="#compat">Compatibility</a><br />
<a href="#ref">References</a><br />
<p />

<h2><a id="samples">Samples</a></h2>
<img src="CompositeApplicationEx/Intro.png" width="600" height="153" alt="Intro.png" />
<p />
To test if my library was up to its goal I have ported three samples to it. 
In all case I was able to reduce the application size and maintain functionality.
<ul>
<li>
Josh Smith <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">MVVM Demo</a>. 
This is the best sample, as it is small and simple yet it covers almost all features of the library 
(after some modifications) and is a real composite application. 
I was able to get rid of the hand written validation code and use 
<code>ValidationAttribute</code> instead. And I tweaked the <code>MainWindow</code> and <code>App</code> 
class to make it a composite application, and use the <code>DataControl</code> in the <code>TabItem</code>
to bind multiple controls to the same model with different view.
</li>
<li>
<a href="http://compositewpf.codeplex.com/">Prism</a>’s main sample, the StockTraderApp project (huge sample). 
I removed the presenters (code which were used to bind views and view models, 
now replaced with call to <code>Composition.GetView()</code> and <code>DataControl</code>), the 
<code>EventAggregator</code> and custom prism events (replaced by <code>Notifications</code> static method). 
The most challenging and interesting part was to get rid of the 
<code>RegionManager</code> and replace it with the <code>IShellView</code> which explicitly 
expose the area of the shell that can be used and get rid of the <code>RegionManager</code>’s magic string approach.
</li>
<li>
<a href="http://mefedmvvm.codeplex.com/">MEFedMVVM</a> library demo. 
The application is relatively simple but it makes extensive usage of design time support, 
and the design time experience is a joy to behold.
</li>
</ul>
The unit tests illustrate how the most important features are working 
(i.e. <code>Composition</code>, <code>Notification</code>, <code>ViewModelBase</code> and <code>Command</code>).

<h2><a id="aboutmef">About MEF and MVVM</a></h2>
Josh Smith talked about <a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">MVVM</a>
extensively on MSDN already. But, to summarize, MVVM is a View Model approach where all the 
logic and information is in the models. And by all I mean all, to the extent of including the 
selected element of a list, or the position of the caret, if need be.
<p /> 
In MVVM the view is nothing more than some declarative XAML (and possibly some UI 
specific code if need be, with no business code at all just pure UI logic). 
And because business data might not express all the information present in a view 
(such as selected area, incorrect value in a text box, etc...), 
business models might be wrapped in view models. View models are business models wrappers 
with a few extra, view-friendly, properties. This offers various advantages including 
increased testability, better separation of concerns, possibility to have independent team for 
business data and UI. 
<p />

<a href="http://mef.codeplex.com/">MEF</a>, or Manage Extensibility Framework, 
solves the problem of passing services and other shared objects around in a very neat way. 
It also enables to find interfaces implementations easily.<br />
Basically “consumer” objects declare what they need with the import attribute, like so:
<pre lang="cs">[Import(typeof(ISomeInterface)]
public ISomeInterface MySome { get; set; }
</pre>
Somewhere else in the code the exporting object are declared with export attribute.
<pre lang="cs">[Export(typeof(ISomeInterface))]
public class SomeInterfaceImplentation : ISomeInterface
{ /** */ }</pre>
<b>Remark</b> properties and methods can be exported. Import can be single object (<code>Import</code>)
or many (<code>ImportMany</code>). I strongly recommend that you read the MEF 
<a href="http://mef.codeplex.com/documentation">documentation</a>.
<br />
To find the implementation for all imports needed by your objects there are 2 actions to be done:
<ol>
<li>
At the start of the program, a “catalog” of types for MEF should be initialized from a list of types, 
assemblies and / or directories, which will be where MEF will look for locating exports. 
It’s where you opt-in for the modules of interest. With this library you’ll call the method 
<code>Composition.Register()</code>, as shown below.</li>
<li>
You “compose” the objects that need to be resolved (i.e. which contains imports). 
With this library you’ll use the method <code>Composition.Compose()</code>.
</li>
</ol>
MEF contains various tags to control whether instances are shared or not, 
whether multiple implementations of an export is valid or not. 
Again this is covered in the <a href="http://mef.codeplex.com/documentation">documentation</a>.

<h2><a id="whatiscapp">What does a composite application look like</a></h2>
A composite application is an application where there is a well-known top level 
UI element, typically a window for a desktop application or a Page for 
Silverlight. This top level UI element is called the “<code>Shell</code>”.
<p/>
The shell contains multiple areas where pluggable content will be hosted. 
Content that is not defined by the shell but in modules that are loaded 
dynamically (with MEF for example).
<p />
For example in the example below a shell is defined with two areas:
<ul>
<li>A list box, showing a single list of documents.</li>
<li>An <code>ItemsControl</code> (a <code>TabControl</code>) which can contains numerous items.</li>
</ul>
<pre lang="cs">
&lt;Window 
	x:Class="DemoApp.MainWindow"
	xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"&gt;
	&lt;Grid&gt;
		&lt;Grid.ColumnDefinitions&gt;
			&lt;ColumnDefinition Width="Auto" /&gt;
			&lt;ColumnDefinition Width="*" /&gt;
		&lt;/Grid.ColumnDefinitions&gt;
		&lt;ListBox
			Grid.Column="0"
			Items="{Binding Documents}"
			Header="Documents"
			/&gt;
		&lt;TabControl 
			Grid.Column="1"
			IsSynchronizedWithCurrentItem="True" 
			ItemsSource="{Binding Workspaces}" 
			ItemContainerStyle="{StaticResource ClosableTabItemStyle}"/&gt;
	&lt;/ Grid &gt;
&lt;/Window&gt;
</pre>
<b>Remark</b> Don’t worry too much about the shell when you create it, 
it is relatively easy to add or move areas later in 
the development, if need be. But it’s harder to remove an area in use!
<p />
Once a shell has been defined, an interface to it should be exposed via a common 
library. It could be a “<code>IShellInterface</code>” (see the <code>IShellView</code>
in the StockTraderApp for example) or its view model (see <code>MainViewModel</code>
in DemoApp for example), or a combination of the two!
<p />
As an example here is the <code>IShellView</code> interface from the StockTraderApp sample:
<pre lang="cs">public enum ShellRegion
{
	MainToolBar,
	Secondary,
	Action,
	Research,
	// this will set the currently selected item
	Main,
}
public interface IShellView
{
	void ShowShell(); // this will show the shell window
	void Show(ShellRegion region, object data);
	ObservableCollection&lt;object&gt; MainItems { get; }
}
</pre>

Once a shell has been defined the composite application can be written. Four 
short steps are involved:
<ol>
<li>Define the DLL that are to be dynamically loaded</li>
<li>Create the shell (or skip and import it in 3.)</li>
<li>Export the shell and import the modules</li>
<li>Start the app / initialize the modules</li>
</ol>
For example, here is what StockTraderApp simplified <code>App</code> code could look like
<pre lang="cs">public partial class App
{
	public App()
	{
		// 1. Opt-in for the DLL of interest (for import-export resolution)
		Composition.Register(
			typeof(Shell).Assembly
			, typeof(IShellView).Assembly
			, typeof(MarketModule).Assembly
			, typeof(PositionModule).Assembly
			, typeof(WatchModule).Assembly
			, typeof(NewsModule).Assembly
			);
		// 2. Create the shell
		Logger = new TraceLogger();
		Shell = new Shell();
	}
 
	[Export(typeof(IShellView))]
	public IShellView Shell { get; internal set; }
 
	[Export(typeof(ILoggerFacade))]
	public ILoggerFacade Logger { get; private set; }
 
	[ImportMany(typeof(IShellModule))]
	public IShellModule[] Modules { get; internal set; }
 
	public void Run()
	{
		// 3. export the shell, import the modules
		Composition.Compose(this);
		Shell.ShowShell();
 
		// 4. Start the modules, they would import the shell
		// and use it to appear on the UI
		foreach (var m in Modules)
			m.Init();
	}
}</pre>

<h2><a id="mainf">Core Features</a></h2>
The library grew quite a lot from its humble beginnings. It consists out of two main 
parts. Feature which are critical to MVMM and composite development and optional 
features which were a useful additions.
<p />
The central class for most features of this library is the <code>Composition</code> class. 
It also contains two important properties, <code>Catalog</code> and <code>Container</code>, 
which are the used for MEF to resolve imports and exports. You need to fill the 
<code>Catalog</code> at the start of the application with <code>Composition.Register()</code>, 
for example:
<pre lang="cs">static App() // init catalog in App’s static constructor
{
	Composition.Register(
		typeof(MapPage).Assembly
		, typeof(TitleData).Assembly
		, typeof(SessionInfo).Assembly
	);
}</pre>
Later service imports and exports can be solved with MEF by calling <code>Composition.Compose()</code>.



<h3><a id="getview">Composition GetView</a></h3>
When an MVVM development pattern is followed, one writes business model and / or 
view models and views for these data models. Typically this view will only 
consist of “XAML code”, and their <code>DataContext</code> property will be the 
business model. Often MVVM helper libraries will provide some ways of finding 
and loading these views.
<p />
In this library the views need to be tagged with a <code>DataViewAttribute</code> 
which specifies for which model type this view is for:
<pre lang="cs">[DataView(typeof(CustomerViewModel))]
public partial class CustomerView : UserControl
{
	public CustomerView()
	{
		InitializeComponent();
	}
}</pre>
Then, from a data model, you can automatically load the appropriate view (and 
set its <code>DataContext</code>) with a call to <code>Composition.GetView()</code>, 
for example:
<pre lang="cs">public void ShowPopup(object message, object title)
{
	var sDialog = new MsgBox();
	sDialog.Message = Composition.GetView(message);
	sDialog.Title = Composition.GetView(title);
	sDialog.Show();
}</pre>
Often models are not displayed as a result of some method call but simply 
because they are an item in an <code>ItemsControl</code> or the content of a
<code>ContentControl</code>. In this case the <code>DataControl</code> 
control can be used in XAML to display the item by calling <code>Composition.GetView()</code>.
<p/>
<b>Remark</b> It also brings a <code>DataTemplate</code> like functionality to Silverlight.
<p />
Because we use a View-Model approach, the same data model can be shown in 
multiple places at the same time hence <code>Composition.GetView()</code>,
<code>DataViewAttribute</code> and the <code>DataControl</code> have an optional
<code>location</code> parameter.
<p />
In the example below, the same <code>UserViewModel</code> instance (subclass of <code>WorkspaceViewModel</code>) 
is used to display both the <code>TabItem</code> header and content using different location parameter 
(<i>note: location is not set, i.e.it is null, in the second template</i>).
<pre lang="xml">&lt;Style x:Key="ClosableTabItemStyle" TargetType="TabItem" BasedOn="{StaticResource {x:Type TabItem}}"&gt;
	&lt;Setter Property="HeaderTemplate"&gt;
		&lt;Setter.Value&gt;
			&lt;DataTemplate&gt;
				&lt;g:DataControl Data="{Binding}" Location="header"/&gt;
			&lt;/DataTemplate&gt;
		&lt;/Setter.Value&gt;
	&lt;/Setter&gt;
	&lt;Setter Property="ContentTemplate"&gt;
		&lt;Setter.Value&gt;
			&lt;DataTemplate&gt;
				&lt;g:DataControl Data="{Binding}"/&gt;
			&lt;/DataTemplate&gt;
		&lt;/Setter.Value&gt;
	&lt;/Setter&gt;
&lt;/Style&gt;</pre>
Both views were defined like this (<i>note the first view is the default view, i.e. location is not set, it is null</i>):
<pre lang="cs">[DataView(typeof(CustomerViewModel))]
public partial class CustomerView : System.Windows.Controls.UserControl
{
	public CustomerView()
	{
		InitializeComponent();
	}
}
[DataView(typeof(WorkspaceViewModel), "header")]
public partial class CustomerHeaderView : UserControl
{
	public CustomerHeaderView()
	{
		InitializeComponent();
	}
}</pre>

<h3><a id="viewmodel">Validation and ViewModelBase</a></h3>
Inspired by 
<a href="http://devlicio.us/blogs/rob_eisenberg/archive/2010/03/16/build-your-own-mvvm-framework-is-online.aspx">Rob Eisenberg’s talk</a>,
I created a <code>ViewModelBase</code> class which implement two important interfaces for WPF development: 
<code>INotifyPropertyChanged</code> and <code>IDataErrorInfo</code>.
<p />
The <code>INotifyPropertyChanged</code> implementation is strongly typed (refactor friendly):
<pre lang="cs">public class Person : ViewModelBase
{
	public string Name
	{
		get { return mName; }
		set
		{
			if (value == mName)
				return;
			mName = value;
			OnPropertyChanged(() => Name); // See, no magic string!
		}
	}
	string mName;
}</pre>

The <code>IDataErrorInfo</code> interface allows the WPF bindings to validate 
the properties they are bound to (if <code>NotifyOnValidationError=true</code>). 
The implementation in <code>ViewModelBase</code> validates the properties using 
<code>ValidationAttribute</code>(s) on the properties themselves. For example:
<pre lang="cs">public class Person : ViewModelBase
{
	[Required]
	public string Name { get; set; }
 
	[Required]
	public string LastName { get; set; }
 
	[OpenRangeValidation(0, null)]
	public int Age { get; set; }
 
	[PropertyValidation("Name")]
	[PropertyValidation("LastName")]
	[DelegateValidation("InitialsError")]
	public string Initials { get; set; }
 
	public string InitialsError()
	{
		if (Initials == null || Initials.Length != 2)
			return "Initials is not a 2 letter string";
		return null;
	}
}</pre>
The example above also illustrates some of the new <code>ValidationAttribute</code> subclasses 
provided in this library, in the <code>Galador.Applications.Validation</code> namespace, i.e.
<pre lang="cs">ConversionValidationAttribute
DelegateValidationAttribute
OpenRangeValidationAttribute
PropertyValidationAttribute</pre>
<p />
A control with an invalid binding will automatically be surrounded by a red 
border (default style), but the error feedback can be customized as shown in 
this XAML fragment below, which display the error message below the validated 
text:
<pre lang="xml">&lt;!-- FIRST NAME--&gt;
&lt;Label 
	Grid.Row="2" Grid.Column="0" 
	Content="First _name:" 
	HorizontalAlignment="Right"
	Target="{Binding ElementName=firstNameTxt}"
	/&gt;
&lt;TextBox 
	x:Name="firstNameTxt"
	Grid.Row="2" Grid.Column="2" 
	Text="{Binding Path=Customer.FirstName, ValidatesOnDataErrors=True, UpdateSourceTrigger=PropertyChanged, BindingGroupName=CustomerGroup}" 
	Validation.ErrorTemplate="{x:Null}"
	/&gt;
&lt;!-- Display the error string to the user --&gt;
&lt;ContentPresenter 
	Grid.Row="3" Grid.Column="2"
	Content="{Binding ElementName=firstNameTxt, Path=(Validation.Errors).CurrentItem}"
	/&gt;</pre>

<h3><a id="msg">Disconnected Messaging</a></h3>
		In a composite application there is a need for components to send messages to 
		each other without knowing each other. The <code>Notifications</code> class and its 
		static methods are here to solve this problem. 
<p/>
First a common message type should be defined in a common library, objects can
<ul>
<li>Subscribe to messages for this type (with the static <code>Subscribe()</code> and
<code>Register()</code> methods).</li>
<li>Publish messages (with <code>Publish()</code>).</li>
<li>Unsubscribe from messages if they are no longer interested in them (with <code>Unsubscribe()</code>).</li>
</ul>
<b>Remark</b> The subscription thread is an optional parameter that can be either the 
original thread, the UI thread or a background thread.
<p />
To illustrate these functionalities here is a snippet of code from the Notifications’ unit test class.
<pre lang="cs">public void TestSubscribe()
{
	// subscribe to a message
	Notifications.Subscribe&lt;NotificationsTests, MessageData&gt;(null, StaticSubscribed, ThreadOption.PublisherThread);

	// publish a message
	Notifications.Publish(new MessageData { });

	// unsubscribe to a message below
	Notifications.Unsubscribe&lt;NotificationsTests, MessageData&gt;(null, StaticSubscribed);
}
 
static void StaticSubscribed(NotificationsTests t, MessageData md)
{
	// message handling
}</pre>
Arguably the <code>Notifications.Subscribe()</code> syntax is a bit cumbersome. 
It’s why an object can also subscribe to multiple message type in one swoop by calling 
<code>Notifications.Register(this)</code>, which will subscribe all its methods with one 
argument and tagged with <code>NotificationHandlerAttribute</code>, as in
<pre lang="cs">public void TestRegister()
{
	// register to multiple message type (1 shown below)
	Notifications.Register(this, ThreadOption.PublisherThread);

	// publish a message
	Notifications.Publish(new MessageData { Info = "h" });
}
 
[NotificationHandler]
public void Listen1(MessageData md)
{
	// message handling
}</pre>


<h3><a id="commands">Commands</a></h3>
To avoid the need for code in the UI, yet handle code triggering controls such 
as a <code>Button</code> or a <code>MenuItem</code>, WPF (and Silverlight 4) came up with commands 
(<code>ICommand</code> to be exact). When a button is clicked the control action is triggered, 
and if it has a Command property it will call <code>Command.Execute(parameter)</code>, where 
the parameter is the <code>Control.CommandParameter</code> property.
<p />
ViewModels need to expose a <code>Command</code> property whose <code>Execute()</code>
method will call one of their methods. For this purpose there is the <code>DelegateCommand</code>.
<p />
A delegate command can be created by passing a method to execute and an optional 
method to check if the method can be executed (which will enable / disable the 
command source, i.e. the button). For example:
<pre lang="cs">var p = new Person();
var save = new DelegateCommand(p, () =&gt; p.CanSave);</pre>

<b>Remark</b> The second argument is an expression. The command will automatically 
<code>INotifyPropertyChanged</code> properties and register to the 
<code>PropertyChanged</code> event to update its <code>CanExecute()</code> status.
<p />
<b>Remark</b> Sometimes you need commands such as “DoAll” as in “CancelAll” or “BuyAll” 
hence the support of <code>ForeachCommand</code> class, which is an <code>ICommand</code> 
itself and can watch a list of <code>ICommand</code>, set its status to CanBeExecuted 
if all its command can be executed.
<p />

<h2><a id="otherf">Utilities</a></h2>
A few other non-essential features found their way into this library.
<p />

<h3><a id="invoker">UIThread Invoke</a></h3>
There is the <code>Invoker</code>, which assist in running code on the GUI thread. 
It can also be used in both WPF and Silverlight.
<pre lang="cs">public class Invoker
{
	public static void BeginInvoke(Delegate method, params object[] args)
	public static void DelayInvoke(TimeSpan delay, Delegate method, params object[] args)
}</pre>
<p />

<h3><a id="designtimemodel">Design time model initialization</a></h3>
There is design time support for the data views. Using the attached property
<code>Composition.DesignerDataContext</code> on a data view sets its 
<code>DataContext</code> at design time:
<pre lang="xml">&lt;UserControl x:Class="MEFedMVVMDemo.Views.SelectedUser"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x=http://schemas.microsoft.com/winfx/2006/xaml
		xmlns:g="http://schemas.galador.net/xaml/libraries"
		xmlns:models="clr-namespace:MEFedMVVMDemo.ViewModels"
		g:Composition.DesignerDataContext="models:SelectedUserViewModel"
		&gt;</pre>
These view models (i.e. DataView’s <code>DataContext</code>) can compose themselves 
(i.e. call <code>Composition.Compose(this)</code>) to import some other services.
<p />
<b>Remark</b> Having a design time <code>DataContext</code> makes the experience of writing a 
<code>DataTemplate</code> a whole lot better.
<p />
<b>Remark</b> These view models can be made aware that they are in design mode if they implement the
<code>IDesignAware</code> interface.
<p />
<b>Remark</b> The services loaded by the models can be different in runtime and design time 
if they are exported with <code>ExportService</code> instead of 
<code>Export</code>, like so
<pre lang="cs">[ExportService(ServiceContext.DesignTime, typeof(IUsersService))]
public class DesignTimeUsersService : IUsersService</pre>
<p />

<h2><a id="pocobinding">POCO Bindings</a></h2>
There are times when you want to synchronize 2 values. 2 classes assist in this endeavour:
<code>PropertyPath</code> and <code>POCOBinding</code>. 
While these classes are not strongly typed they have some strongly typed  
<code>public static Create&lt;T&gt;</code> method to help alleviate error creating them.<br />
Here is how 2 integer properties can be synchronized:
<pre lang="cs">var p1 = new Person();
var p2 = new Person();
POCOBinding.Create&lt;Person, Person, int&gt;(p1, aP => aP.Boss.Age, p2, aP2 => aP2.Age);
</pre>
And here is how a value can be set through a <code>PropertyPath</code>
<pre lang="cs">var p1 = new Person();
var pp = PropertyPath.Create&lt;string&gt;(() => p1.Boss.Name);

//.....
pp.Value = "Foo";
Assert.AreEqual(p1.Boss.Name, "Foo");
</pre>

<b>Remark</b> <code>PropertyPath</code> implements <code>INotifyPropertyChanged</code>.
<p />


<h2><a id="foreach">Foreach</a></h2>
There are multiple variations of the <code>Foreach</code> classes which can be used 
to observe an <code>IEnumerable</code> or an <code>ObservableCollection</code>
and take whatever action is appropriate when something in the collection changes.

<h2><a id="summary">Summary</a></h2>
Hopefully this article and the samples it contains will have shown what a 
composite application architecture looks like and how this library makes it easy 
to solve the key problems most often met by a composite application:
<ul>
<li>Resolving services dependencies using MEF.</li>
<li>Finding DataView for DataModel with <code>DataControl</code> or <code>Composition.GetView()</code>.</li>
<li>Implement common MVVM pattern: the <code>ICommand</code> (with <code>DelegateCommand</code> and
<code>ForeachCommand</code>) and disconnected messaging (with <code>Notifications</code>).</li>
<li>Implement data binding validation with <code>ValidationAttribute</code> in a subclass of 
<code>ViewModelBase</code>.</li>
</ul>

<h2><a id="compat">Compatibility</a></h2>
This library will work with the Client Profile for .NET4 and Silverlight 4.
<p />
If need to be ported to .NET3.5 there are two obstacles.
<ul>
<li>MEF, which is on <a href="http://www.codeplex.com/">CodePlex</a>.</li>
<li>And the Validator class, used in the <code>ViewModelBase</code> to validate the properties from the 
<code>ValidationAttribute</code>(s), i.e. implement the <code>IDataErrorInfo</code> 
interface. Only two methods need to be reimplemented from the <code>Validator</code>.</li>
</ul>


<h2><a id="ref">References</a></h2>
MEF on Codeplex (it’s also part of .NET4 &amp; Silverlight 4)<br />
<a href="http://mef.codeplex.com/">http://mef.codeplex.com/</a>
<p />
Prism, aka the composite application library<br />
<a href="http://compositewpf.codeplex.com/">http://compositewpf.codeplex.com/</a>
<p />
Josh Smith on MVVM<br />
<a href="http://msdn.microsoft.com/en-us/magazine/dd419663.aspx">http://msdn.microsoft.com/en-us/magazine/dd419663.aspx</a>
<p />
Rob Eisenberg on MVVM<br />
<a href="http://devlicio.us/blogs/rob_eisenberg/archive/2010/03/16/build-your-own-mvvm-framework-is-online.aspx">http://devlicio.us/blogs/rob_eisenberg/archive/2010/03/16/build-your-own-mvvm-framework-is-online.aspx</a>
<p />
The MEFedMVVM library<br />
<a href="http://mefedmvvm.codeplex.com">http://mefedmvvm.codeplex.com</a>

</body>
</html>